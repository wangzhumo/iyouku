# 锁解决并发数据

## mysql中锁的概念

**行级锁、表级锁**

悲观锁与乐观锁的概念是从应用的角度来看的，从数据库(InnoDB 存储引擎)的角度看，数据库锁可以分为行级

锁和表级锁(通常称为行锁和表锁)

#### 行级锁

锁住的是行记录,行级锁可以大大减少数据库操作的冲突，但是加锁的开销也是非常大的。

- 由于开销比较大
- 加锁会很慢 锁定粒度小，所以锁冲突的概率低，并发度高 
- 可能会出现死锁

#### 表级锁

- 由于开销比较小，加锁会很快 
- 锁定粒度大，所以锁冲突的概率高，并发度低 
- 不会出现死锁



**总结下来:**

- 不通过索引条件查询时，InnoDB 一定会使用表锁，而不是行锁(因为没有索引只能全表扫描) 

- 查询时，不论是使用主键索引、唯一索引或者普通的索引，InnoDB 都会使用行锁来对数据加锁

对于数据量很少的表，MySQL 会认为 全表扫描更快，此时，即使使用索引字段查询，InnoDB 也会使用表锁，而不是行锁。

## 悲观锁、乐观锁

### 概念解读

#### 悲观锁

当我们要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据 进行加锁以防止并发。这种借助数据库锁机制在修改数据之前锁定，再修改的方式被称为悲观并发控制 (PCC)

它会以悲观的态度去对待并发的数据控制，认为共享数据被并发修改的可能 性较高，在修改之前先去加锁。在实现效率上，处理加锁的过程会让数据库产生额外的开销，降低并发度，同时， 还可能会有死锁的可能。

悲观锁的实现，依赖于数据库提供的锁机制(行级锁、表级锁)。它的**工作流程**可以总结如下:

- 对数据操作之前，尝试获取锁 
- 获取锁成功，对数据进行修改、提交事务，最后释放锁 
- 获取锁失败，则锁正在被占用，等待或抛出异常

#### 乐观锁

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才 会正式对数据的冲突与否进行检测。

乐观(锁) 并发控制认为事务之间的数据竞争概率比较低，因此在操作时不需要加锁，只是在提交时再做判断，它也不会产生 死锁的情况。

乐观锁其实是对 CAS(compare-and-swap)的实现:在做修改时，检查当前的环境是否与预定义的一致，如果一 致则可以提交;否则，重试或抛异常。



### 实现原理与使用方法

在 MySQL 中使用悲观锁，必须关闭 MySQL 的自动提交(MySQL 默认使用自动提交模式，即执行 INSERT、 UPDATE、DELETE 时，结果自动生效)

```sql
-- 关闭自动提交
mysql> SET autocommit = off;
-- 校验自动提交是否关闭
mysql> SHOW VARIABLES LIKE 'autocommit';
```

#### 使用悲观锁

MySQL 提供的悲观锁实现方式是:`SELECT ... FOR UPDATE`。

```sql
-- “会话 A” 通过悲观锁语法锁住 id 为 1 的记录
mysql> SELECT * FROM worker WHERE id = 1 FOR UPDATE; 
+----+------+------+--------+
|id|type|name|salary|
+----+------+------+--------+
|1 |A   |tom |1800  |
+----+------+------+--------+
-- “会话 B” 也通过悲观锁语法锁住 id 为 1 的记录
-- 由于锁被 “会话 A” 占据，长时间获取不到锁，报了锁超时错误
mysql> SELECT * FROM worker WHERE id = 1 FOR UPDATE;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
```

这里会话B就发生了获取锁时间过长,产生了超时的异常

在使用悲观锁的时候，一定需要注意使用索引，否则行锁将会上 升为表锁，引起系统问题。

#### 使用乐观锁

```sql
 -- 查询需要修改的记录，并把当前 salary 的值作为预定义的比对条件 
mysql> SELECT * FROM worker WHERE id = 1; 

+----+------+------+--------+
|id|type|name|salary|
+----+------+------+--------+ 
|1 |A   |tom |2000  | 
+----+------+------+--------+ 
1 row in set (0.00 sec)

-- 更新记录 salary 的值，并比对之前预定义的条件是否一致
mysql> UPDATE worker SET salary = 1800 WHERE id = 1 AND salary = 2000; 

Query OK, 1 row affected (0.00 sec)
Rows matched: 1 Changed: 1 Warnings: 0

-- 比对一致，更新成功
mysql> SELECT * FROM worker WHERE id = 1; 
+----+------+------+--------+ 
|id|type|name|salary| 
+----+------+------+--------+
|1 |A   |tom |1800  | 
+----+------+------+--------+
1 row in set (0.00 sec)
```

以上的操作就是最简单的乐观锁，但是它不能处理 ABA 值的问题

查询是A    更新A之前另一个线程先把 A 更新为 B  并且再次更新为A

这样的情况下，虽然A最后仍然是A，但是中间的B过程就被忽略了，所以我们加入`version` or `timestamp`这样的东西来保证

```sql
-- 给 worker 表添加 version 列

mysql> ALTER TABLE `worker` ADD COLUMN `version` BIGINT(20) NOT NULL DEFAULT '0' COMMENT '乐观锁版本号'; 
Query OK, 0 rows affected (0.18 sec)
Records: 0 Duplicates: 0 Warnings: 0

-- 读取数据，记录 version 的值
mysql> SELECT * FROM worker WHERE id = 1; 
+----+------+------+--------+---------+ 
|id  |type  |name  |salary  |version  | 
+----+------+------+--------+---------+
|1	 |A     |tom   |1800    | 0       | 
+----+------+------+--------+---------+
1 row in set (0.00 sec)

-- 比对 version 是否符合预期，更新数据和 version
mysql> UPDATE worker SET salary = 2000, version = version + 1 WHERE id = 1 AND version = 0; 
Query OK, 1 row affected (0.00 sec)
Rows matched: 1 Changed: 1 Warnings: 0

-- 再次读取数据，校验是否符合预期
mysql> SELECT * FROM worker WHERE id = 1; 
+----+------+------+--------+---------+ 
|id  |type  |name  |salary  |version  | 
+----+------+------+--------+---------+
|1   |A     |tom   |2000    | 1       | 
+----+------+------+--------+---------+
1 row in set (0.00 sec)
 
```

优点：因为并没有真的使用锁，所以它的效率很高

缺点：当遇到高并发时，只可能会有一个线程修改成功，会造成大量的线程失败或重试

### 悲观锁、乐观锁的适用场景

#### 优缺点

**悲观锁**是依赖于数据库(存储引擎)的，它的优缺点总结如下:

- 优点:利用锁机制保证了数据的顺序执行，不需要自己控制，加锁、释放完全由数据库代劳 

- 缺点:一旦一个事务获取了锁，其他的事务必须等待，势必会影响系统的吞吐量

**乐观锁**不是真正的加锁，对其他事务友好，它的优缺点总结如下:

- 优点:由于不需要加锁，其他的事务可以同时操作数据，相比于悲观锁，系统吞吐量会提高 

- 缺点:需要自行控制，如果并发度较高，失败重试的情况会成为系统瓶颈

#### 合理应用

- 悲观锁的适用场景:写入操作比较频繁的场景，如果有大量的读取操作，每次读取都需要加锁，会增加锁开 销，降低系统的吞吐量 
- 乐观锁的适用场景:读取操作比较频繁的场景，如果有大量的写入操作，冲突的可能性会剧增，降低系统的吞 吐量

